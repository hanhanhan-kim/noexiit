#!/usr/bin/env python3

"""
Process and visualize FicTrac data with helper functions. 
When run as a script, transforms .dat FicTrac files into a single concatenated \
Pandas dataframe with some additional columns. Then performs various processing \
and plotting of the FicTrac data. Includes visualization of the frequency domain, \
low-pass Butterworth filtering, ___. 
"""

import argparse
import glob
from sys import exit

import numpy as np
import pandas as pd
import scipy.interpolate as spi
import scipy.signal as sps
import scipy.signal as sps

from bokeh.io import output_file, export_png, export_svgs, show
from bokeh.plotting import figure
from bokeh.models import Span
from bokeh.layouts import gridplot
from bokeh.palettes import brewer

from fourier_transform import fft, bokeh_freq_domain


def parse_dats(names, framerate, ball_radius):
    '''
    Takes a list of .dat files generated by FicTrac and returns a single 
    concatenated dataframe.
    The pre-processed dataframe is given proper headings, as informed by 
    the documentation on rjdmoore's FicTrac GitHub page. 
    All values are converted into floats, except for the frame and sequence 
    counters, which are converted into ints. In addition, elapsed time is 
    converted into seconds and minutes, and the integrated X and Y positions 
    are converted to real-world values, by multiplying them against the ball 
    radius. 
    
    Parameters:
    -----------
    names (list): A list of default .dat files generated by FicTrac (ver 2)
    framerate: The framerate of the acquisition of the videos FicTrac 
    analyzes. 
    # TODO: compute the framerate, rather than take as an arg
    # TODO: input asking for verification that the ball_radius is in mm

    ball_radius (float): The radius of the ball (mm) the insect was on. 
    Used to compute the real-world values in mm.  

    Returns:
    --------
    A single Pandas dataframe that concatenates all the input .dat files.
    '''
    headers = [ "frame_cntr",
                "delta_rotn_vector_cam_x", 
                "delta_rotn_vector_cam_y", 
                "delta_rotn_vector_cam_z", 
                "delta_rotn_err_score", 
                "delta_rotn_vector_lab_x", 
                "delta_rotn_vector_lab_y", 
                "delta_rotn_vector_lab_z",
                "abs_rotn_vector_cam_x", 
                "abs_rotn_vector_cam_y", 
                "abs_rotn_vector_cam_z",
                "abs_rotn_vector_lab_x", 
                "abs_rotn_vector_lab_y", 
                "abs_rotn_vector_lab_z",
                "integrat_x_posn",
                "integrat_y_posn",
                "integrat_animal_heading",
                "animal_mvmt_direcn",
                "animal_mvmt_spd",
                "integrat_fwd_motn",
                "integrat_side_motn",
                "timestamp",
                "seq_cntr",
                "delta_timestamp",
                "alt_timestamp" ]
    
    dfs = []

    for idx, dat in enumerate(names):
        with open(dat, 'r') as f:
            next(f) # skip first row
            df = pd.DataFrame((l.strip().split(',') for l in f), columns=headers)

        # Convert all values to floats:
        df = df[headers].astype(float)

        # Convert the values in the frame and sequence counters columns to ints:
        df['frame_cntr'] = df['frame_cntr'].astype(int)
        df['seq_cntr'] = df['seq_cntr'].astype(int)

        # Compute real-world values:
        df['X_mm'] = df['integrat_x_posn'] * ball_radius
        df['Y_mm'] = df['integrat_y_posn'] * ball_radius
        df['speed_mm'] = df['animal_mvmt_spd'] * ball_radius

        # Compute elapsed time:
        df['secs_elapsed'] = df['frame_cntr']/framerate
        df['mins_elapsed'] = df['secs_elapsed']/60
        
        # Discretize minute intervals as strings:
        df['min_int'] = df['mins_elapsed'].astype('int') + 1
        df['min_int'] = df['min_int'].apply(str)

        # Assign animal number:
        df['animal'] = idx 

        dfs.append(df)

    dfs = pd.concat(dfs)
        
    return dfs


def plot_fictrac_fft(dfs, val_col, time_col, 
                    even=False, window=np.hanning, pad=1, 
                    cutoff_freq=None, 
                    save=True, show_plots=True):
    
    """
    Perform a Fourier transform on FicTrac data for each animal. Generate 
    frequency domain plots for each animal. Outputs plots. 

    Parameters:
    ------------
    dfs (DataFrame): Concatenated dataframe of FicTrac data generated from 
        parse_dats()

    val_col (str): Column name of the dfs dataframe to be Fourier-transformed.  

    time_col (str): Column name of the dfs dataframe that specifies time in 
        in SECONDS. 

    even (bool): If False, will interpolate even sampling. 

    cutoff_freq (float): x-intercept value for plotting a vertical line. 
        To be used to visualize a candidate cut-off frequency. Default is None.

    save (bool): If True, will save .png plots. Default is True. 

    show_plots (bool): If True, will show plots, but will not 
        output a list of Bokeh plotting objects. If False, will not show 
        plots, but will output a list of Bokeh plotting objects. If both 
        save and show_plots are True, .html plots will be generated, in addition 
        to the .png plots. Default is True.

    Returns:
    ---------
    if show_plots is True: will show plots but will not output bokeh.plotting.figure
         object.

    if show_plots is False: will output a list of bokeh.plotting.figure objects, 
        but will not show plots.

    if save is True: will save .png plots.
    
    if both show_plots and save are True, will show plots and save .png and .html 
        plots. 

    if both show_plots and save are False, will return nothing. 
    """
    if ("sec" or "secs") not in time_col:
        safe_secs = input(f"The substrings 'sec' or 'secs' was not detected in \
            the 'time_col' variable, {time_col}. The units of the values in \
            {time_col} MUST be in seconds. If the units are in seconds, please \
            input 'y'. Otherwise input 'n' to exit.")
        while True:
            if safe_secs.lower() == "y":
                break
            else:
                exit("Re-run this function with a 'time_col' whose units are secs.")

    bokeh_ps = []
    for animal in range(len(dfs["animal"].unique())):

        df = dfs.loc[dfs["animal"]==animal]

        assert (len(df[time_col] == len(df[val_col]))), \
            "time and val are different lengths! They must be the same."
        assert (time_col in dfs), \
            f"The column, {time_col}, is not in the input dataframe, {dfs}"
        assert (val_col in dfs), \
            f"The column, {val_col}, is not in the input dataframe, {dfs}"
        assert ("animal" in dfs), \
            f"The column 'animal' is not in in the input dataframe, {dfs}"

        time = list(df[str(time_col)])
        val = list(df[str(val_col)])

        # Fourier-transform:
        f = spi.interp1d(time, val)

        if even is False:
            time_interp = np.linspace(time[0], time[-1], len(time))
            val_interp = f(time_interp)
        else:
            time_interp = time
            val_interp = val

        amp, _, freq = fft( val_interp, 
                            time_interp, 
                            pad=1, 
                            window=window, 
                            post=True)

        # Plot:
        p1, p2 = bokeh_freq_domain(freq, amp)

        p1.title.text = f"frequency domain: animal {animal}"
        p1.title.text_font_size = "16pt"
        p1.yaxis.axis_label_text_font_size = "12pt"
        p2.yaxis.axis_label_text_font_size = "12pt"
        p2.xaxis.axis_label_text_font_size = "12pt"

        if cutoff_freq is not None:
            float(cutoff_freq)
            cutoff_line = Span(location=cutoff_freq, 
                               dimension="height", 
                               line_color="#e41a1c",
                               line_dash="dashed",
                               line_width=2)
            p1.add_layout(cutoff_line)
            p2.add_layout(cutoff_line)

        p = gridplot([p1, p2], ncols=1)

        # Output:
        if save is True:
            # Bokeh does not atm support gridplot svg exports
            export_png(p, f"fictrac_freqs_{animal}.png")
            output_file(f"fictrac_freqs_{animal}.html", 
                        title=f"fictrac_freqs_{animal}")

        if show_plots is True:
            show(p)
        else:
            bokeh_ps.append(p)
        
    if show_plots is False:
        return bokeh_ps

        # TODO: save in each FicTrac subdir? I think output_file 
        # has a root_dir arg         


def plot_fictrac_filter(dfs, val_col, time_col, 
                        framerate, order, cutoff_freq,  
                        val_label=None, time_label=None,
                        view_perc=1.0, 
                        show_plots=True, save=True):
    
    """
    Apply a low-pass Butterworth filter on offline FicTrac data. 
    # TODO: Compute framerate, rather than accept as arg

    Parameters:
    -----------
    dfs (DataFrame): Concatenated dataframe of FicTrac data generated from 
        parse_dats()

    val_col (str): Column name of the dfs dataframe to be Fourier-transformed.  

    time_col (str): Column name of the dfs dataframe that specifies time. 

    framerate (float): The acquisition framerate of the FicTrac camera.

    order (int): Order of the filter.

    cutoff_freq (float): The cutoff frequency for the filter in Hz.  

    val_label (str): Label for the plot's y-axis. 

    time_label (str): Label for the plot's time-axis. 

    view_perc (float): Specifies how much of the data to plot as an initial \
        percentage. Useful for assessing the effectieness of the filter over longer \
        timecourses. Default is set to 1, i.e. plot the data over the entire \
        timecourse. Must be a value between 0 and 1.

    save (bool): If True, will save .svg and .png plots. Default is True. 

    show_plots (bool): If True, will show plots, but will not 
        output a list of Bokeh plotting objects. If False, will not show 
        plots, but will output a list of Bokeh plotting objects. If both 
        save and show_plots are True, .html plots will be generated, in addition 
        to the .svg and .png plots. Default is True.

    Returns:
    --------
    if show_plots is True: will show plots but will not output bokeh.plotting.figure
         object.

    if show_plots is False: will output a list of bokeh.plotting.figure objects, 
        but will not show plots.

    if save is True: will save .svg and .png plots.
    
    if both show_plots and save are True, will show plots and save .svg, .png and 
        .html plots. 

    if both show_plots and save are False, will return nothing. 
    """
    
    assert (0 <= view_perc <= 1), \
        f"The view percentage, {view_perc}, must be between 0 and 1."
    
    bokeh_ps = []
    for animal in range(len(dfs["animal"].unique())):
        
        df = dfs.loc[dfs["animal"]==animal]
        
        assert (len(df[time_col] == len(df[val_col]))), \
            "time and val are different lengths! They must be the same."
        assert (time_col in dfs), \
            f"The column, {time_col}, is not in the input dataframe, {dfs}"
        assert (val_col in dfs), \
            f"The column, {val_col}, is not in the input dataframe, {dfs}"
        assert ("animal" in dfs), \
            f"The column 'animal' is not in in the input dataframe, {dfs}"
        
        time = list(df[str(time_col)])
        val = val = list(df[str(val_col)])
        
        # Design low-pass filter:
        b, a = sps.butter(int(order), cutoff_freq, fs=framerate)
        # Apply filter:
        val_filtered = sps.lfilter(b, a, val)
        
        # View the first _% of the data:
        domain = int(view_perc * len(val))
        
        # Plot:
        if val_label is None:
            val_label = val_col.replace("_", " ")
        if time_label is None:
            time_label = time_col.replace("_", " ")
        
        p = figure(
        background_fill_color="#efe8e2",
        width=1600,
        height=500,
        x_axis_label=time_label,
        y_axis_label=val_label 
        )

        p.line(
            x=time[:domain],
            y=val[:domain],
            color=brewer["Paired"][3][0],
            legend_label="raw"
        )
        p.line(
            x=time[:domain],
            y=val_filtered[:domain],
            color=brewer["Paired"][3][1],
            legend_label="filtered"
        )
        
        p.title.text = f"animal {animal}, first {view_perc * 100}% with butterworth filter: cutoff={cutoff_freq} Hz, order={order}"
        p.title.text_font_size = "14pt"
        p.yaxis.axis_label_text_font_size = "12pt"
        p.yaxis.axis_label_text_font_size = "12pt"
        p.xaxis.axis_label_text_font_size = "12pt"
        
        # Output:
        if save is True:
            filename = f"fictrac_filter_{animal}"
            
            p.output_backend = "svg"
            export_svgs(p, filename=filename + ".svg")
            export_png(p, filename=filename + ".png")
            output_file(filename=filename + ".html", 
                        title=filename)
            
        if show_plots is True:
            # In case this script is run in Jupyter, change output_backend 
            # back to "canvas" for faster performance:
            p.output_backend = "canvas"
            show(p)
        else:
            bokeh_ps.append(p)
        
    if show_plots is False:
        return bokeh_ps


def main():

    parser = argparse.ArgumentParser(description = __doc__)
    parser.add_argument("root",
        help="Absolute path to the root directory. I.e. the outermost \
            folder that houses the output files.\
            E.g. /mnt/2TB/data_in/test/")
    parser.add_argument("nesting", type=int,
        help="Specifies the number of folders that are nested from \
            the root directory. I.e. The number of folders between root \
            and the subdirectory that houses the output files. E.g. 1")
    parser.add_argument("framerate", type=float,
        help="") #TODO: COMPUTE!
    parser.add_argument("ball_radius", type=float,
        help="The radius of the ball used with the insect-on-a-ball tracking rig. \
            Must be in mm.")
    parser.add_argument("val_col", 
        help="Column name of the Pandas dataframe to be used as the dependent \
            variable for analyses.")
    parser.add_argument("val_label", nargs="?", default=None,
        help="y-axis label of the generated plots. Default is a formatted \
            val_col")
    parser.add_argument("time_col",
        help="Column name of the Pandas dataframe specifying the time.")
    parser.add_argument("time_label", nargs="?", default=None,
        help="time-axis label of the generated plots. Default is a formatted \
            time_col")
    parser.add_argument("cutoff_freq", type=float,
        help="Cutoff frequency to be used for filtering the FicTrac data.")
    parser.add_argument("order", type=int,
        help="Order of the filter.")
    parser.add_argument("view_percent", type=float,
        help="Specifies how much of the data to plot as an initial \
            percentage. Useful for assessing the effectieness of the filter over \
            longer timecourses. Default is set to 1, i.e. plot the data over the \
            entire timecourse. Must be a value between 0 and 1.")
    parser.add_argument("-s", "--save", action="store_false", default=True,
        help="If enabled, does not save the plots. By default, saves the plots.")
    parser.add_argument("-sh", "--show", action="store_true", default=False,
        help="If enabled, shows the plots. By default, does not show the plots.")
    
    args = parser.parse_args()

    root = args.root
    nesting = args.nesting #TODO: use nesting and root

    framerate = args.framerate #TODO: compute, rather than input
    ball_radius = args.ball_radius # mm

    val_col = args.val_col
    val_label = args.val_label
    time_col = args.time_col
    time_label = args.time_label

    cutoff_freq = args.cutoff_freq
    order = args.order
    view_perc =args.view_percent

    save = args.save
    show_plots = args.show

    "*.dat"

    dats = sorted(glob.glob(root))
    concat_df = parse_dats(dats, framerate, ball_radius)

    # Plot FFT frequency domain:
    plot_fictrac_fft(concat_df, val_col, time_col, 
                     cutoff_freq=cutoff_freq, 
                     show_plots=show_plots, save=save)

    plot_fictrac_filter(concat_df, val_col, time_col, 
                        framerate = framerate,
                        order = order, cutoff_freq = cutoff_freq, 
                        val_label=val_label, 
                        time_label=time_label,
                        view_perc=view_perc,
                        show_plots=False, save=save) 